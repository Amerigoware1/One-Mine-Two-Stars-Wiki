<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ares Chronometer</title>
<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="stylesheet" href="WikiStyle.css">
<style>
    
body {
      font-family: 'Inter', sans-serif;
      background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e);
      color: #e5e7eb;
      margin: 0;
      padding: 20px;
      min-height: 100vh;
	  padding-top: 72px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .top-banner {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: rgba(0, 0, 0, 0);
      /* backdrop-filter: blur(10px); */
      padding: 12px 20px;
      text-align: left;
      border-bottom: 1px solid rgba(0, 255, 136, 0.3);
      z-index: 1000;
    }

    .home-button {
    display: inline-block;
    background: rgba(0, 255, 136, 0.15);
    color: #00ff88;
    font-weight: 600;
    padding: 8px 20px;
    border: 1px solid #00ff88;
    border-radius: 30px;
    text-decoration: none;
    transition: all 0.3s ease;
    min-width: 100px;
}

.home-button:hover {
    background: #00ff88;
    color: #000;
    box-shadow: 0 0 15px rgba(0, 255, 136, 0.6);
}
    
    .chronometer {
        background: linear-gradient(145deg, #1a1a1a, #2a2a2a);
        border: 2px solid #00ff88;
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 0 30px rgba(0, 255, 136, 0.3), inset 0 0 20px rgba(0, 255, 136, 0.1);
        max-width: 1000px;
        width: 100%;
    }
    
    .main-display {
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 30px;
        margin-bottom: 30px;
    }
    
    .left-panel {
        display: flex;
        flex-direction: column;
    }
    
    .time-display { text-align: center; margin-bottom: 30px; }
    .metric-time {
        font-size: 3em; font-weight: 900; color: #00ff88;
        text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        margin-bottom: 10px;
        font-variant-numeric: tabular-nums;
    }
    .standard-time { font-size: 1.2em; color: #88ffaa; opacity: 0.7; }

    .cycle-info { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px; }
    .info-panel {
        background: rgba(10,0,26);
        border: 1px solid rgba(0, 255, 136, 0.3);
        border-radius: 10px; padding: 15px;
    }
    .info-panel h4 { margin: 0 0 10px 0; color: #00ffaa; font-size: 0.9em; text-transform: uppercase; }
    .info-panel .value { font-size: 1.4em; font-weight: 700; }

    .lighting-forecast { text-align: center; margin-bottom: 30px; }
    .current-lighting {
        font-size: 1.6em; font-weight: 700;
        margin-bottom: 15px; padding: 15px;
        border-radius: 10px; text-transform: uppercase;
    }
    .bright   { background: linear-gradient(45deg, #fff700, #ffd700); color: #000; text-shadow: none; }
    .dim      { background: linear-gradient(45deg, #ff6600, #cc4400); color: #fff; }
    .g_only   { background: linear-gradient(45deg, #ffff88, #eeee66); color: #000; text-shadow: none; }
    .k_only   { background: linear-gradient(45deg, #ffaa44, #dd8822); color: #fff; }
    .luminous { background: linear-gradient(45deg, #4444aa, #6666cc); color: #fff; }
    .dark     { background: linear-gradient(45deg, #111111, #333333); color: #888; }

    .day-timeline {
        height: 40px; background: #000; border-radius: 20px;
        margin: 15px 0; position: relative; overflow: hidden;
        border: 1px solid rgba(0, 255, 136, 0.3);
    }
    .timeline-fill { height: 100%; display: flex; border-radius: 19px; }
    .timeline-fill div { min-width: 1px; }
    .time-marker {
        position: absolute; top: 0; width: 2px; height: 100%;
        background: #00ff88; box-shadow: 0 0 10px rgba(0, 255, 136, 0.8); z-index: 10;
    }

    .orbital-diagram {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(0, 255, 136, 0.3);
        border-radius: 10px;
        padding: 20px;
        height: 300px;
        position: relative;
        overflow: hidden;
    }
    
    .orbital-diagram canvas {
        width: 100%;
        height: 100%;
        display: block;
    }

    .temperature-display {
        background: rgba(10,0,26);
        border: 1px solid rgba(0, 255, 136, 0.4);
        border-radius: 12px; padding: 20px; margin: 20px 0; text-align: center;
    }
    .current-temp { font-size: 2.2em; font-weight: 900; margin-bottom: 10px; }
    .temp-hot { color: #ff4444; text-shadow: 0 0 10px rgba(255,68,68,0.5); }
    .temp-warm { color: #ffaa00; text-shadow: 0 0 10px rgba(255,170,0,0.5); }
    .temp-cool { color: #00aaff; text-shadow: 0 0 10px rgba(0,170,255,0.5); }
    .temp-cold { color: #4488ff; text-shadow: 0 0 10px rgba(68,136,255,0.5); }
    .temp-freezing { color: #88aaff; text-shadow: 0 0 10px rgba(136,170,255,0.5); }
    .temp-range { display: flex; justify-content: space-between; margin-top: 15px; font-size: 1.1em; }
    .temp-high { color: #ff6666; }
    .temp-low  { color: #6666ff; }

    .temp-tooltip { position: relative; cursor: help; }
    .temp-tooltip:hover::after {
        content: attr(data-fahrenheit);
        position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%);
        background: rgba(0,0,0,0.9); color: #00ff88;
        padding: 6px 10px; border-radius: 6px;
        font-size: 0.9em; white-space: nowrap; z-index: 1000;
        border: 1px solid rgba(0,255,136,0.3);
        box-shadow: 0 0 10px rgba(0,255,136,0.2);
    }
    .temp-tooltip:hover::before {
        content: '';
        position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%) translateY(100%);
        border: 5px solid transparent; border-top-color: rgba(0,0,0,0.9); z-index: 1000;
    }

    .orbital-display { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-top: 20px; }
    .orbital-panel {
        background: rgba(10,0,26);
        border: 1px solid rgba(0, 255, 136, 0.2);
        border-radius: 8px; padding: 10px; text-align: center;
    }
    .orbital-panel h5 { margin: 0 0 8px 0; font-size: 0.8em; color: #88ffaa; text-transform: uppercase; }
    .orbital-value { font-size: 1.1em; font-weight: 700; }

    .controls { text-align: center; margin-top: 20px; }

	<button>Advance Time</button>

    .weather-msg {
        background: rgba(10,0,26);
        border: 1px solid rgba(0, 255, 136, 0.3);
        border-radius: 10px;
        padding: 15px; margin-top: 20px;
        font-style: italic; color: #88ffaa;
    }
    
    @media (max-width: 768px) {
        .main-display {
            grid-template-columns: 1fr;
        }
        .orbital-diagram {
            height: 250px;
        }
    }
</style>
</head>

<body>
	<div class="top-banner">
  <a href="index.html" class="home-button">üè† Home</a>
</div>
<div class="card-bg gradient-border mb-4">
    <div class="main-display">
        <div class="left-panel">
            <div class="time-display">
                <div class="metric-time" id="metric-time">06:91:73</div>
                <div class="standard-time" id="standard-time">(12:27 PM Standard)</div>
            </div>
            
            <div class="cycle-info">
                <div class="info-panel"><h4>Ares Sol</h4><div class="value" id="ares-day">Day 27 of 45</div></div>
                <div class="info-panel"><h4>Chaos Year</h4><div class="value" id="chaos-year">Day 82 of 400</div></div>
            </div>
            
            <div class="lighting-forecast">
                <div class="current-lighting" id="current-lighting">Binary Starlight</div>
                <div class="day-timeline">
                    <div class="timeline-fill" id="timeline-fill"></div>
                    <div class="time-marker" id="time-marker"></div>
                </div>
            </div>
        </div>
        
        <div class="orbital-diagram">
            <canvas id="orbital-canvas"></canvas>
        </div>
    </div>
    
    <div class="temperature-display">
        <div class="current-temp temp-tooltip" id="current-temp" data-fahrenheit="75.4¬∞F">24.2¬∞C</div>
        <div style="font-size: 0.9em; color: #88ffaa; margin-bottom: 10px;">Current Temperature</div>
        <div class="temp-range">
            <div class="temp-low">Low: <span class="temp-tooltip" id="temp-low" data-fahrenheit="62.6¬∞F">17.0¬∞C</span></div>
            <div class="temp-high">High: <span class="temp-tooltip" id="temp-high" data-fahrenheit="88.2¬∞F">31.2¬∞C</span></div>
        </div>
    </div>
    
    <div class="orbital-display">
        <div class="orbital-panel"><h5>Eclipse Status</h5><div class="orbital-value" id="eclipse-status">No Eclipse</div></div>
        <div class="info-panel"><h4>Chaos Illumination</h4><div class="value" id="chaos-illumination">67%</div></div>
        <div class="orbital-panel"><h5>Binary Season</h5><div class="orbital-value" id="binary-season">Mid-orbit</div></div>
    </div>
    
    <div class="weather-msg" id="weather-msg">Clear binary starlight conditions with moderate temperatures. Perfect for outdoor activities with standard UV protection recommended.</div>
    
    <div class="controls">
        <button onclick="advanceTime()">Advance Time</button>
        <button onclick="randomTime()">Random Time</button>
        <button id="realTimeButton" onclick="toggleRealTime()">Enable Real-Time Mode</button>
    </div>
</div>

<script>
let currentTime = { metric: [6,91,73], ares_day: 27, chaos_day: 82 };
let realTimeInterval = null;

function metricToStandard(metric) {
    const totalMetricUnits = metric[0]*10000 + metric[1]*100 + metric[2];
    const totalStandardMinutes = (totalMetricUnits/100000) * (18*60);
    const hours = Math.floor(totalStandardMinutes/60);
    const minutes = Math.floor(totalStandardMinutes%60);
    return `${hours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}`;
}

function getStarEclipseState() {
    const chaosAngle = (currentTime.chaos_day / 400) * 2 * Math.PI;
    const aresAngle = (currentTime.ares_day / 45) * 2 * Math.PI;
    const binaryAngle = chaosAngle * 1.2;
    
    // Calculate positions relative to system center
    const chaosOrbitRadius = 120;
    const aresOrbitRadius = 25;
    
    const chaosX = chaosOrbitRadius * Math.cos(chaosAngle);
    const chaosY = chaosOrbitRadius * Math.sin(chaosAngle);
    const aresX = chaosX + aresOrbitRadius * Math.cos(aresAngle);
    const aresY = chaosY + aresOrbitRadius * Math.sin(aresAngle);
    
    // Binary star positions
    const binaryScale = 25;
    const niamhDistance = binaryScale * 0.6;
    const ciaraDistance = binaryScale * 1.4;
    const niamhX = niamhDistance * Math.cos(binaryAngle);
    const niamhY = niamhDistance * Math.sin(binaryAngle);
    const ciaraX = -ciaraDistance * Math.cos(binaryAngle);
    const ciaraY = -ciaraDistance * Math.sin(binaryAngle);
    
    // Check if Chaos eclipses the stars from Ares perspective
    const angleToBinary = Math.atan2((niamhY + ciaraY)/2 - aresY, (niamhX + ciaraX)/2 - aresX);
    const angleToChaos = Math.atan2(chaosY - aresY, chaosX - aresX);
    
    let angleDiff = Math.abs(angleToBinary - angleToChaos);
    if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
    
    const eclipseThreshold = 0.4;
    if (angleDiff < eclipseThreshold) {
        return 'chaos_eclipse';
    }
    
    // Check individual star eclipses
    const angleToNiamh = Math.atan2(niamhY - aresY, niamhX - aresX);
    const angleToCiara = Math.atan2(ciaraY - aresY, ciaraX - aresX);
    
    let niamhDiff = Math.abs(angleToNiamh - angleToChaos);
    let ciaraDiff = Math.abs(angleToCiara - angleToChaos);
    
    if (niamhDiff > Math.PI) niamhDiff = 2 * Math.PI - niamhDiff;
    if (ciaraDiff > Math.PI) ciaraDiff = 2 * Math.PI - ciaraDiff;
    
    const starEclipseThreshold = 0.25;
    
    if (niamhDiff < starEclipseThreshold && ciaraDiff < starEclipseThreshold) {
        return 'total_star_eclipse';
    } else if (niamhDiff < starEclipseThreshold) {
        return 'g_eclipsed';
    } else if (ciaraDiff < starEclipseThreshold) {
        return 'k_eclipsed';
    }
    
    return 'none';
}

function getLightingType(metricTime, eclipseState) {
    const t = (metricTime[0]*10000 + metricTime[1]*100 + metricTime[2]) / 100000;
    
    // New Eden's position on Ares - day/night cycle
    // At t=0, New Eden is at angle 0 (facing binary stars = day)
    // At t=0.5, New Eden is at angle œÄ (facing away from stars = night)
    const newEdenAngle = t * 2 * Math.PI;
    
    // Calculate angle to binary stars from New Eden's perspective
    const chaosAngle = (currentTime.chaos_day / 400) * 2 * Math.PI;
    const aresAngle = (currentTime.ares_day / 45) * 2 * Math.PI;
    const binaryAngle = chaosAngle * 1.2;
    
    // Simplified: if New Eden angle is roughly aligned with binary direction, it's day
    // Day occurs when New Eden faces roughly toward the binary stars (¬±90 degrees)
    const facingStars = Math.cos(newEdenAngle) > 0;
    
    // Night time - New Eden faces away from stars
    if (!facingStars) {
        const chaosIllumination = ((Math.cos((currentTime.ares_day/45)*2*Math.PI)+1)/2);
        return chaosIllumination > 0.3 ? 'luminous' : 'dark';
    }
    
    // Daytime - New Eden faces stars, check for eclipses
    switch(eclipseState) {
        case 'chaos_eclipse':
        case 'total_star_eclipse':
            return 'dim';
        case 'g_eclipsed': 
            return 'k_only';
        case 'k_eclipsed': 
            return 'g_only';
        case 'none': 
        default: 
            return 'bright';
    }
}

function getTemperatureClass(temp) {
    if (temp >= 35) return 'temp-hot';
    if (temp >= 20) return 'temp-warm';
    if (temp >= 5) return 'temp-cool';
    if (temp >= -10) return 'temp-cold';
    return 'temp-freezing';
}

function drawOrbitalDiagram() {
    const canvas = document.getElementById('orbital-canvas');
    if (!canvas || !canvas.getContext) {
        console.error("Could not find canvas element or get its context.");
        return; 
    }

    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;

    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
    ctx.lineWidth = 1;
    
    const chaosAngle = (currentTime.chaos_day / 400) * 2 * Math.PI;
    const aresAngle = (currentTime.ares_day / 45) * 2 * Math.PI;
    
    const chaosOrbitRadius = 120;
    const aresOrbitRadius = 25;
    
    const binaryAngle = chaosAngle * 1.2;
    const binaryScale = 25;
    const niamhDistance = binaryScale * 0.6;
    const ciaraDistance = binaryScale * 1.4;
    
    const niamhX = centerX + niamhDistance * Math.cos(binaryAngle);
    const niamhY = centerY + niamhDistance * Math.sin(binaryAngle);
    const ciaraX = centerX - ciaraDistance * Math.cos(binaryAngle);
    const ciaraY = centerY - ciaraDistance * Math.sin(binaryAngle);
    
    const chaosX = centerX + chaosOrbitRadius * Math.cos(chaosAngle);
    const chaosY = centerY + chaosOrbitRadius * Math.sin(chaosAngle);
    
    const aresX = chaosX + aresOrbitRadius * Math.cos(aresAngle);
    const aresY = chaosY + aresOrbitRadius * Math.sin(aresAngle);
    
    // Draw orbital paths
    ctx.beginPath();
    ctx.arc(centerX, centerY, chaosOrbitRadius, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(chaosX, chaosY, aresOrbitRadius, 0, 2 * Math.PI);
    ctx.stroke();
    
    ctx.strokeStyle = 'rgba(255, 255, 136, 0.15)';
    ctx.setLineDash([1, 3]);
    ctx.beginPath();
    ctx.arc(centerX, centerY, niamhDistance, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(centerX, centerY, ciaraDistance, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // System center
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.beginPath();
    ctx.arc(centerX, centerY, 2, 0, 2 * Math.PI);
    ctx.fill();
    
    // Binary stars
    ctx.fillStyle = '#ffff88';
    ctx.beginPath();
    ctx.arc(niamhX, niamhY, 8, 0, 2 * Math.PI);
    ctx.fill();
    
    ctx.fillStyle = '#ffaa44';
    ctx.beginPath();
    ctx.arc(ciaraX, ciaraY, 6, 0, 2 * Math.PI);
    ctx.fill();
    
    // Chaos (super-Jupiter)
    const gradient = ctx.createRadialGradient(chaosX, chaosY, 0, chaosX, chaosY, 15);
    gradient.addColorStop(0, '#4466aa');
    gradient.addColorStop(1, '#223366');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(chaosX, chaosY, 15, 0, 2 * Math.PI);
    ctx.fill();
    
    // Ares
    ctx.fillStyle = '#aa6644';
    ctx.beginPath();
    ctx.arc(aresX, aresY, 4, 0, 2 * Math.PI);
    ctx.fill();
    ctx.strokeStyle = '#00ff88';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    // New Eden position
    const tDay = (currentTime.metric[0]*10000 + currentTime.metric[1]*100 + currentTime.metric[2]) / 100000;
    const newEdenAngle = tDay * 2 * Math.PI;
    const settlementRadius = 6;
    const newEdenX = aresX + settlementRadius * Math.cos(newEdenAngle);
    const newEdenY = aresY + settlementRadius * Math.sin(newEdenAngle);
    
    ctx.fillStyle = 'red';
    ctx.beginPath();
    ctx.arc(newEdenX, newEdenY, 2, 0, 2 * Math.PI);
    ctx.fill();
    
    // Draw eclipse lines if applicable
    const eclipseState = getStarEclipseState();
    if (eclipseState !== 'none') {
        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
        ctx.lineWidth = 2;
        ctx.setLineDash([3, 3]);
        
        if (eclipseState === 'chaos_eclipse' || eclipseState === 'total_star_eclipse') {
            const binaryCenterX = (niamhX + ciaraX) / 2;
            const binaryCenterY = (niamhY + ciaraY) / 2;
            ctx.beginPath();
            ctx.moveTo(aresX, aresY);
            ctx.lineTo(chaosX, chaosY);
            ctx.lineTo(binaryCenterX, binaryCenterY);
            ctx.stroke();
        } else if (eclipseState === 'g_eclipsed') {
            ctx.beginPath();
            ctx.moveTo(aresX, aresY);
            ctx.lineTo(chaosX, chaosY);
            ctx.lineTo(niamhX, niamhY);
            ctx.stroke();
        } else if (eclipseState === 'k_eclipsed') {
            ctx.beginPath();
            ctx.moveTo(aresX, aresY);
            ctx.lineTo(chaosX, chaosY);
            ctx.lineTo(ciaraX, ciaraY);
            ctx.stroke();
        }
        ctx.setLineDash([]);
    }
    
    // Labels
    ctx.fillStyle = '#88ffaa';
    ctx.font = '10px Orbitron';
    ctx.textAlign = 'center';
    ctx.fillText('Niamh (G)', niamhX, niamhY - 15);
    ctx.fillText('Ciara (K)', ciaraX, ciaraY - 12);
    ctx.fillText('Chaos', chaosX, chaosY + 25);
    ctx.fillText('Ares', aresX + 10, aresY - 10);
    
    // Day/night indicator for New Eden
    const facingStars = Math.cos(newEdenAngle) > 0;
    ctx.fillStyle = facingStars ? '#ffff00' : '#000080';
    ctx.font = '8px Orbitron';
    ctx.fillText(facingStars ? 'Day' : 'Night', newEdenX, newEdenY + 8);
}

function updateDisplay() {
    document.getElementById('metric-time').textContent = `${currentTime.metric[0].toString().padStart(2,'0')}:${currentTime.metric[1].toString().padStart(2,'0')}:${currentTime.metric[2].toString().padStart(2,'0')}`;
    document.getElementById('standard-time').textContent = `(${metricToStandard(currentTime.metric)} Standard)`;
    document.getElementById('ares-day').textContent = `Day ${currentTime.ares_day} of 45`;
    document.getElementById('chaos-year').textContent = `Day ${currentTime.chaos_day} of 400`;

    const eclipseState = getStarEclipseState();
    const lighting = getLightingType(currentTime.metric, eclipseState);
    
    const names = {
        bright:'Binary Starlight', 
        dim:'Eclipse Period', 
        g_only:'Ciara Light (K-Star)',
        k_only:'Niamh Light (G-Star)', 
        luminous:'Chaos IR-lit Night', 
        dark:'True Night'
    };
    
    const le = document.getElementById('current-lighting');
    le.textContent = names[lighting]; 
    le.className = `current-lighting ${lighting}`;

    // Update timeline
    const tf = document.getElementById('timeline-fill'); 
    tf.innerHTML = '';
    for (let i = 0; i < 100; i++) {
        const seg = document.createElement('div');
        const timeOfDay = i / 100;
        const simulatedEclipse = getStarEclipseState();
        const segmentLighting = getLightingType([Math.floor(timeOfDay*10), Math.floor((timeOfDay*10%1)*100), 0], simulatedEclipse);
        seg.className = segmentLighting;
        seg.style.flex = '1';
        tf.appendChild(seg);
    }
    
    const t = (currentTime.metric[0]*10000 + currentTime.metric[1]*100 + currentTime.metric[2]) / 100000;
    document.getElementById('time-marker').style.left = `${t*100}%`;

    // Eclipse status
    const eclipseNames = {
        'none': 'No Eclipse', 
        'chaos_eclipse': 'Chaos Eclipse', 
        'total_star_eclipse': 'Total Star Eclipse',
        'g_eclipsed': 'G-Star Eclipsed', 
        'k_eclipsed': 'K-Star Eclipsed'
    };
    document.getElementById('eclipse-status').textContent = eclipseNames[eclipseState];

    const ci = Math.round(((Math.cos((currentTime.ares_day/45)*2*Math.PI)+1)/2)*100);
    document.getElementById('chaos-illumination').textContent = `${ci}%`;

    // Temperature calculations
    let stellarFactor = 0.08;
    if (lighting === 'bright') stellarFactor = 0.7;
    else if (lighting === 'g_only') stellarFactor = 0.45;
    else if (lighting === 'k_only') stellarFactor = 0.35;
    else if (lighting === 'dim') stellarFactor = 0.25;
    else if (lighting === 'luminous') stellarFactor = 0.15;
    else if (lighting === 'dark') stellarFactor = 0.05;
    
    const chaosAngle = (currentTime.chaos_day / 400) * 2 * Math.PI;
    const chaosDistance = 1.0 + 0.4 * Math.cos(chaosAngle);
    const distanceHeatingFactor = 1.0 / (chaosDistance * chaosDistance);
    
    const aresAngle = (currentTime.ares_day / 45) * 2 * Math.PI;
    const aresOrbitalHeatFactor = (Math.cos(aresAngle - chaosAngle) + 1) / 2;
    
    const baseDistanceHeat = 8 * distanceHeatingFactor;
    const chaosIRbonus = (ci / 100) * 8;
    const dailyCycle = 18 * (0.5 - Math.abs(0.5 - t));
    const baseTemp = 12;
    const temp = baseTemp + baseDistanceHeat + chaosIRbonus + (dailyCycle * stellarFactor * distanceHeatingFactor * (0.5 + aresOrbitalHeatFactor));
    
    const ce = document.getElementById('current-temp');
    ce.textContent = `${temp.toFixed(1)}¬∞C`;
    ce.className = `current-temp temp-tooltip ${getTemperatureClass(temp)}`;
    ce.setAttribute('data-fahrenheit', `${(temp*9/5+32).toFixed(1)}¬∞F`);

    const tempRangeFactor = 7.1;
    const low = temp - (tempRangeFactor * (0.5 + aresOrbitalHeatFactor));
    const high = temp + (tempRangeFactor * (0.5 + aresOrbitalHeatFactor));
    const lo = document.getElementById('temp-low');
    const hi = document.getElementById('temp-high');
    lo.textContent = `${low.toFixed(1)}¬∞C`;
    hi.textContent = `${high.toFixed(1)}¬∞C`;
    lo.setAttribute('data-fahrenheit', `${(low*9/5+32).toFixed(1)}¬∞F`);
    hi.setAttribute('data-fahrenheit', `${(high*9/5+32).toFixed(1)}¬∞F`);

    const sp = (currentTime.chaos_day/400) * 2 * Math.PI;
    const sep = (Math.cos(sp) + 1) / 2;
    document.getElementById('binary-season').textContent = sep > 0.7 ? 'Apastron' : sep < 0.3 ? 'Periastron' : 'Mid-orbit';

    // Weather message
    let msg = "";
    if (lighting === 'bright') {
        msg = "Clear binary starlight conditions with moderate temperatures. Perfect for outdoor activities with standard UV protection recommended.";
    } else if (lighting === 'dim') {
        msg = "Eclipse conditions causing reduced lighting and cooler temperatures. Good visibility for sensitive observations.";
    } else if (lighting === 'g_only' || lighting === 'k_only') {
        msg = "Partial eclipse conditions with single-star illumination. Unique lighting creates interesting atmospheric effects.";
    } else if (lighting === 'luminous') {
        msg = "Night period with Chaos providing infrared illumination. Excellent conditions for infrared astronomy and thermal imaging.";
    } else {
        msg = "True night conditions with minimal illumination. Optimal for optical astronomy and stargazing.";
    }
    
    if (temp > 35) msg += " Extreme heat conditions - seek shade and stay hydrated.";
    else if (temp > 25) msg += " Warm conditions - light clothing recommended.";
    else if (temp < 10) msg += " Cool conditions - warm clothing advised.";
    
    document.getElementById('weather-msg').textContent = msg;
    
    drawOrbitalDiagram();
}

function advanceTime() {
    currentTime.metric[2] += 10;
    if (currentTime.metric[2] >= 100) {
        currentTime.metric[2] = 0;
        currentTime.metric[1]++;
    }
    if (currentTime.metric[1] >= 100) {
        currentTime.metric[1] = 0;
        currentTime.metric[0]++;
    }
    if (currentTime.metric[0] >= 10) {
        currentTime.metric[0] = 0;
        currentTime.ares_day++;
        currentTime.chaos_day++;
    }
    if (currentTime.ares_day > 45) currentTime.ares_day = 1;
    if (currentTime.chaos_day > 400) currentTime.chaos_day = 1;
    updateDisplay();
}

function randomTime() {
    currentTime.metric = [
        Math.floor(Math.random()*10),
        Math.floor(Math.random()*100),
        Math.floor(Math.random()*100)
    ];
    currentTime.ares_day = Math.floor(Math.random()*45) + 1;
    currentTime.chaos_day = Math.floor(Math.random()*400) + 1;
    updateDisplay();
}

function toggleRealTime() {
    const btn = document.getElementById('realTimeButton');
    if (realTimeInterval) {
        clearInterval(realTimeInterval);
        realTimeInterval = null;
        btn.textContent = 'Enable Real-Time Mode';
    } else {
        realTimeInterval = setInterval(advanceTime, 200);
        btn.textContent = 'Disable Real-Time Mode';
    }
}

document.addEventListener("DOMContentLoaded", () => {
    randomTime();
});

window.addEventListener("resize", () => {
    updateDisplay();
});
</script>

</body>

</html>




